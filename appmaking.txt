## Part 1: Installing
1. Making a project- choose a dir then type "django-admin startproject
{project name.let's use (mysite)}"

2. Making an app- python3 manage.py startapp {name. lets use (main)}.

adittional: (Making a simple message 'hello world')
1. Go to polls/views.py and type:
from django.http import HttpResponse

def func1(request):
    return HttpResponse('hello world')

2. Make a file urls.py at main and type:
from django.urls import path
from . import views

urlpatterns = [
    path('helloworld/',views.func1)
]

3. In mysite/urls.py, follow the ff. for URLConf/URL Configuration

## Part 2: Database setting up, creating first model, and a quick intro to
Django’s automatically-generated admin site
1. Database Setup
- Head to the mysite/settings.py and as you notice it is full of module-level
stuffs. 

1.1. Database dictionary- Django has installed database already which is SQLite.
But you can change your db if you want, other db like mySQL, oracle, etc.
As if you notice the DATABASE dict, it contains 2 items:
* ENGINE (depends what backend and db you are using)
* NAME (contains full path (including filename). The default val contains 
BASE_DIR / 'db.sqlite3' will store that file in project dir)

1.2. Set the TIME_ZONE on your timezone

1.3. INSTALLED_APPS- it has all the app names. It has default apps which is
listed because of the common cases. List your apps in here by typing the dir
of apps upto class inside the apps.py.
Format: {app nm}.apps.{app nm}Config - class from apps.py
EX: main.apps.MainsConfig

1.4. Migrating- to migrate, type 'python3 manage.py migrate'. It creates a 
necessary db tables based on apps present at INSTALLED_APPS and writes
them in your backend/db.

2. Creating Models
Model.py- contains fields(models) and characteristics of your data stored

2.1. Fields(models/classes)- represented  by every instance inside.
- in our example like the ToDoList field/model, we have instances;
*name = models.CharField(maxlength=200), is for character fields

- On Items field, we have a ForeignKey() which is to identify relationship
between two fields/classes. Thats why it contains Question class as its
parameter. Its 2nd parameter is 'on_delete = models.CASCADE' means if we 
delete item/s ToDoList, we also delete its data in Items

- We also add __str__() inside each models that returns something they
contain.

3. Activating Models
3.1. Django apps can be use in different django projects just make sure they
are listed on INSTALLED_APPS at inner django project folder/settings.py.

- Run the code; "python3 manage.py makemigrations main" to declare
to django that you make some changes on your models (also your database
schema) and you want to save the changes on disk(through migration).

3.2. main/migrations/0001_initial.py saves the migrations that happened.
They are editable, incase you want to modify something

3.3. command "python3 manage.py sqlmigration main 0001": takes migration
names and returns their SQL

Note the following:
- The exact output will vary depending on the database you are using. The
example above is generated for PostgreSQL.
- Table names are automatically generated by combining the name of the app
(polls) and the lowercase name of the model – question and choice. (You can
override this behavior.)

- Primary keys (IDs) are added automatically. (You can override this, too.)

- By convention, Django appends "_id" to the foreign key field name. (Yes,
you can override this, as well.)

- The foreign key relationship is made explicit by a FOREIGN KEY constraint.
Don’t worry about the DEFERRABLE parts; it’s telling PostgreSQL to not
enforce the foreign key until the end of the transaction.

- It’s tailored to the database you’re using, so database-specific field
types such as auto_increment (MySQL), serial (PostgreSQL), or integer
primary key autoincrement (SQLite) are handled for you automatically. Same
goes for the quoting of field names – e.g., using double quotes or single
quotes.

- The sqlmigrate command doesn’t actually run the migration on your db
instead,
it prints it to the screen so that you can see what SQL Django
thinks is required. It’s useful for checking what Django is going to do or
if you have database administrators who require SQL scripts for changes.

3.4. python manage.py check; this checks for any problems in your project
without making migrations or touching the database.


3.5. 3 steps in making model changes
- Change your models (in models.py).
- 'python manage.py makemigrations' to create migrations for those changes
- 'python manage.py migrate' to apply those changes to the database.

* Migrations are very powerful and let you change your models over time, as you develop your project, without the need to delete your database or tables
and make new ones - it specializes in upgrading your database live, without
losing data.

4. Writing and Saving in Database
4.1. Open iPython for manage.py via: python3 manage.py shell.

4.2. Import your models: from main.models import ToDoList,Items.

4.3. Adding data in database is just easy. Lets try adding some data: 
t = ToDoList(name="Michael's Studies"). To save it, simply add: t.save().

4.4. ToDoList.objects.all(): To see all your object, run.

4.5. ToDoList.objects.get(id={object id}): To get a specific data using id.

4.6. ToDoList.objects.get(name='{word}'): to search via name.

4.7. To show its items from relative class:
format: t.{relative class name}_set.all()
ex: t.items_set.all()

4.8. To add items in todolist at t, you must use t.items_set.create(follow the
patterns(give what the instances onto they need)).
Ex: t.items_set.create(text='Finish django',complete=False)

4.9. If you already exit the iPython and you want to access the db inside it,
just import again what we import before to access this db.

*Working to show this datas in a webpage

1. Lets edit the urlpatterns at main/urls.py to looks like this:
	urlpatterns = [path("<int:id>", views.index, name = "index")]

2. Then at the views.py: from .models import todolist,items

3. The "<int:id>" means it needs an int which is an id for an items/todolist.

4. Lets also modify index()
	def index(response, id):
		ls  = todolist.objects.get(id = id)
		itm = ls.items_set.get(id = 1)
		return HttpResponse('<h1>%s</h1></br><p>%s</p>' % (ls.name,itm.text))

ADDITIONAL; If you want to search something in your db, try:
todolist.objects.filter(name__startwith='{str}')

5. Admin dashboard
5.1. Run 'python3 manage.py createsuperuser' then sign up there

5.2. Next, go to your admin page through {link}/admin/ and log in there.
You can see there all the objects registered.

5.3. To register a model and its data;
	-Go to admin.py at app folder then, import a model
		-Ex: from .models import todolist
	-To register: admin.site.register({model})
		-Ex: admin.site.register(todolist)

6. Customizing Templates
6.1. Create a templates dir inside the main dir, then inside templates create
main dir. Should looks like this: mysite/main/templates/main/

6.2. Create a 2 different pages; base.html and home.html
	- make a page at base.html then import it in home.html

	- WHY SEPARATE?! Because it is for all of the users. It gives a user
	a starting/home page independently so you dont need to code it all for
	your users individually.
	-base.html example texts:
			<!DOCTYPE html>
			<html>
			<head>
				<title>Todo Fucking List</title>
			</head>
			<body>
				<h1>Title</h1>
				<p>paragraph</p>
			</body>
			</html>

6.3. Showing objects in Browser
-Add this in main/urls.py/urlpatterns: path("", views.home, name = "home")

-Remove the </p> and change the </h1> to => <h1>{{name}}</h1>. Remember,
{{name}} is a variable

-Write this code in your main/views.py:
	def index(response,id):
		cnt = todolist.objects.get(id = id)
		return render(response,'main/base.html',{'name':cnt.name})

	def home(response):
		return render(response,'main/home.html',{'name':'test'})
--this means if you had id in link, it returns the list.name, else returns
  the word test


6.4. Showing objects with its item in Browser
6.4.1. Modify the base.html:
	<!DOCTYPE html>
	<html>
	<head>
		<!-- using blocks:allows us to insert/modify all of inside of it when
		modifying it from other file just make sure put blocks & insert thing
		on its middle -->
		<title>{% block title %}Todo Fucking List{% endblock %}</title>
	</head>
	<body>
		<div id='content',name='content'>
			{% block content %}
			{% endblock %}
		</div>

	</body>
	</html>

-{blocks} - to modify that part in some cases


6.4.2. Modify the views.py:
	from .models import todolist,items

	def index(response,id):
		cnt = todolist.objects.get(id = id)
		return render(response,'main/list.html',{'cnt':cnt})

	def home(response):
		return render(response,'main/home.html',{})

-@ index(), we get the id as an input. We access what that id contains and we
return its value


6.4.3. Create and modify the list.html
	<!-- Import -->
	{% extends 'main/base.html' %}

	{% block content %}
	<!-- It get the name of the object that we get from the index() in no.2 -->
	<h1>{{cnt.name}}</h1>

	<!-- making lists, <li> for list items -->
	<ul>
		<!-- a python code were it get all the items inside that object -->
		{% for items in cnt.items_set.all %}
			<!--asks if the task is complete or not - get the complete instance-->
			{% if items.complete == True %}
				<!-- return all the items using this -->			
				<li>{{items.text}} - COMPLETE</li>
			{% else %}
				<li>{{items.text}} - INCOMPLETE</li>
			{% endif %} <!-- ends if statement here -->
		{% endfor %} <!-- ends the loop here -->
	</ul>

	{% endblock %}


7. Making Simple Forms
2 ways in getting db info:
-post >> private. Ex:getting password/modifying datas
-get >> access what the link you passed contain

7.1 Make a path at urlpatterns.
Ex: path("create/", views.create,name="create"),

7.2. At mysite/main/, create and modify the forms.py:
	from django import forms

	# Main back bone of the form
	"""
	Django automatically write a js code to render this in browser when its 
	passed inside the form tag
	"""
	class createnewlist(forms.Form):
		name = forms.CharField(label='Name',max_length=200)
		check = forms.BooleanField(required=False)

## Understanding this- Make you form template first like this

7.3. Modify the create.html:
	<!-- Import -->
	{% extends 'main/base.html' %}

	<!-- Change the title -->
	{% block title %}Create List{% endblock %}

	{% block content %}
	Create List
	<!-- form tags must have a submit button -->
	<form method='post', action='/create/'>
		{% csrf_token %} <!-- must add when making form tags -->
		<!-- to show it as an unordered list (ul) -->
		{{form.as_ul}}
		<button type='submit',name='save'>Create New</button>
	</form>
	{% endblock %}

## Understanding this- rewrites the template 'base.html' for view

7.4. Modify the views.py:
	from .forms import createnewlist
	from django.http import HttpResponse,HttpResponseRedirect

	# this gets the form at the forms.py and render it in create.html
	def create(response):
		# we set it to post so its always
		if response.method == 'POST':
			form = createnewlist(response.POST)
			# asks if the data you enter fills the need info
			if form.is_valid():
				# get the raw data name
				n = form.cleaned_data['name']
				# adds it to as our new todolist
				t = todolist(name=n)
				t.save()
				# redirect us to the object we created
				return HttpResponseRedirect('/%i' % t.id)

		else:
			form = createnewlist()
		return render(response,'main/create.html',{'form':form})

## Understanding this- connects to the form and returns what to render

8. Custom Forms
-adding 2 functioning buttons on each list: add item and save changes button

-Modify the index function at views.py
def index(response,id):
	ls = todolist.objects.get(id = id)

	if response.method == 'POST':
		print(response.POST)
		if response.POST.get('save'):
			for item in ls.items_set.all():
				if response.POST.get("c" + str(item.id)) == 'clicked':
					item.complete = True
				else:
					item.complete = False
				item.save()

		elif response.POST.get('newItem'):
			txt = response.POST.get("new")
			if  len(txt) > 2:
				ls.items_set.create(text=txt,complete=False)
			else:
				print('INVALID')

	return render(response,'main/list.html',{'ls':ls})

##Understanding this- as we know, views.py is connected to the list.html and
to models.py also its database. 

*At the first if, it asks if the method is post or not/maybe get. And it is
always be POST because this is wwhat we set in list.html.

	*The second if is asking if you call 'save' or 'newwItem'. They had both
	different functions. If we proceed to 'save', as we see we will have a
	for loop to return each item in items_set.

		*The 3rd if asks if its checkbox is checked/clicked, then it
		sets the 'item.complete' to True. If not, False.

	*Else if we proceed to 'newItem' / if response == 'newItem', it will
	create a new task/list item by what you typed in the input box, If its
	len < 2, its 'invalid'


-Modify list.html
<!-- Import -->
{% extends "main/base.html" %}
{% block title %}View List{% endblock %}
 
{% block content %}
	<h1>{{ls.name}}</h1>
	<form method="post" action="#">
	{% csrf_token %}
		<ul>
			{% for item in ls.item_set.all %}
				{% if item.complete == True %}
			<!-- this inputs could give you checkbox of clomplete and not -->
					<li><input type="checkbox", value="clicked", name="c{{item.id}}" checked>{{item.text}}</li>
				{% else %}
					<li><input type="checkbox", value="clicked", name="c{{item.id}}">{{item.text}}</li>
				{% endif %}
			{% endfor %}
		</ul>
		<!-- This buttons for adding/saving items -->
		<button type="submit", name="newItem", value="newItem">Add Item</button>
		<input type="text", name="new">
		<button type="submit", name="save", value="save">Save</button>
    </form>
{% endblock %}

##Understanding this- its just normal so lets proceed to the for loop part.
On each list item, we put checkbox on it. If the task is complete or
(item.complete == True), we check its checkbox, else, not. At the bottom
part, those are the add and save buttons. If you click in save, the list.html
send a response to the views.py and says the user press the save button. And
if the Add Item button is clicked, it send a response to views.py that tells
the Add Item button was clicked. If it was clicked, it gets the texts inside
the input tag. If len(text) > 2, then it creates it as a new item on the 
items_set for that todolist.

9. Adding a sidebar (optional)
-We're making a sidebar for easier accessing other pages like Home,Todolists,
etc.

-At the body tag, append 'a' tags for directing to links:
	<div class='sidenav'>
		<a href='/'>Home</a>
		<a href='/create'>Create List</a>
		<a href='/2'>View</a>
	</div>
-and also add class='main' at inside the div tag for the {% block content %}

-At the top of the hed tag in base.html, append for positioning the a tags:
	<style type="text/css">
		body{
			display: flex;
			margin: 0;
			padding: 0;
			gap: 50px;
		}

		.sidenav {
			height: 100%;
			width: 160px;
			height: 100vh;
			background-color: #111;
			overflow-x: hidden;
			padding-top: 20px; 
		}

		.sidenav a{
			padding: 6px 8px 6px 16px;
			text-decoration: none;
			font-size: 25px;
			color: #818181;
			display: block;
		}

	.sidenav a:hover{
		color: #f1f1f1;
	}
	.main{
		margin-left: 160px;
		padding: 0px 10px;

	}
	</style>


9. Adding bootstrap(for custom built in stylings)
- In base.html/head tag below style, append the ff. for a default bootstrap design:
   <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

- Then at the bottom inside the body tag, append the ff. js source to activate some
style:
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


10. User Registration & Sign up page

## 10-A. Making a simple account

1. Installing an app for registration
-To have a registration page we must install it a new app for it by:
python3 manage.py startapp {app name(but lets just call it "register")} 

2. Make a response
-Make a response function at the views. Response that contains template to show for
your registration app. For now, lets leave it empty. EX: def register(response): pass

3. Make a template
-Now let's create its template. In your registration app(register) folder, mkdir
"templates/register", inside, create and modify register.html.
Ex:
{% extends "main/base.html" %}

{% block title %}Sign Up{% endblock %}

{% block content %}
	<form method = 'post', class="form-group">
		{% csrf_token %} 	<!-- must added in making forms -->
		{{form}}	<!-- must pass some forms from views -->
		<button type="submit" class='btn btn-success'>Sign Up</button>
	</form>
{% endblock %}


-We have to pass some forms inside it from the register() in views.py. But first lets
make a path to access views.py.

4. Make a path through it
-Next, import the views from the app you make for registration and make a link
through your app directly (what i mean about directly is from "1st urls" -> "views";
unlike "1st urls" -> "2nd urls" -> "views" that we did before) at the urlpatterns
inside mysite/urls.py.
Ex: (at the top)-> from register import views as v
at (urlpatterns)-> path("register/",)
-we set the module(views.py) to other name incase we import other views

5. Making actions from views
-Modify the views.py in register app folder
# import for making accounts
from django.contrib.auth import login,authenticate
from django.contrib.auth.forms import UserCreationForm

# Create your views here.
def register(response):
	# Making accounts using the built in form
	if response.method == 'POST': # always because we set it
		form = UserCreationForm(response.POST) # make an account from info you enter
		if form.is_valid(): # if the new node satisfies the requirements, save it
			form.save()
		return redirect('/')
	else:
		form = UserCreationForm() 
	return render(response, 'register/register.html', {'form':form})

ADDITIONAL: If you make an account, you can see it inside the admin dashboard

## 10-B. Making account with emails
1. Make forms.py file in your register

2. In making forms we must import forms:
from django import forms

3. Import the ff to have a built in sign up forms:
# import for making accounts
from django.contrib.auth import login,authenticate
from django.contrib.auth.forms import UserCreationForm

4. Make registration form inside a class:
class RegistrationForm(UserVreationForm):
	email = forms.EmailField()

5. Import this to write on the db of the user:
from django.contrib.auth.models import User


6. Inside the RegistrationForm() class, add a new class named meta which its job is
to write on the user's database. The RegistrationForm() clas should look like this:
class RegistrationForm(UserVreationForm):
	email = forms.EmailField()

	class meta:
		model = User
		fields = ['username','email','password1','password2']
		# Remember:Those list items has built in values need to recieve, not just str

7. Remove what we import for sign up forms at register/views.py and import our form
for singing up (RegistrationForm class) and use it instead UserCreationForm so it
looks like this:
def register(response):
	# Making accounts using the built in form
	if response.method == 'POST': # always because we set it
		form = RegistrationForm(response.POST) # make an account from info you enter
		if form.is_valid(): # if the new node satisfies the requirements, save it
			form.save()
		return redirect('/')
	else:
		form = RegistrationForm() 
	return render(response, 'register/register.html', {'form':form})

8. Install py module django-crispy-forms: pip3 install django-crispy-forms

9. List down "crispy_forms" on your INSTALLED_APPS in mysite/seyyings.py the add the
ff. at the bootom of settings.py:
# we set this up to bootstrap 4 because our website is using bootstrap 2
CRISPY_TEMPLATE_PACK = 'bootstrap4'

10. Go back to register.html and type "{% load crispy_forms_tags %}"" below the block
title then change {{form}} to {{form|crispy}} so your register.html should looks like
this:
{% extends "main/base.html" %}

{% block title %}Sign Up{% endblock %}
{% load crispy_forms_tags %}

{% block content %}
	<form method = 'post', class="form-group">
		{% csrf_token %} 	<!-- must added in making forms -->
		{{ form|crispy }}	<!-- must pass some forms from views -->
		<button type="submit" class='btn btn-success'>Log In</button>
	</form>
{% endblock %}
## HINT: crispy tags make it look better

11. Making a Login/Log out page and User Authentication
11.A. Making a login/log out page

1. Make a dir to built in django login forms at the urlpatterns in mysite/urls.py:
path('',include('django.contrib.auth.urls'))
## UNDERSTANDING THIS: This built in django authentication folder directs you to your
login page

2. At the templates dir, make another dir named 'registration' and inside it make a 
login.html file that contains: 
{% extends 'main/base.html' %}

{% block title %}Log In{% endblock %}

{% load crispy_forms_tags %}

{% block content %}
<form method='post' class='form-group'>
	{% csrf_token %}
	{{form|crispy}}
	<p>Sign up <a href="/register">here</a></p>
	<hr>
	<button type="submit" class='btn btn-success'>Log in</button>
</form>
{% endblock %}
## ADDITIONAL: We didn't make logical codes in this place because our dir was already
make the real job for us Just make sure the dir name must be 'registration' and the
html name was 'login'. To access the login page we must type {link}/login. If we
login in this state, it send us to 404 page, means unfound. If you look to the link,
it is trying to direct us to the '/profile/accounts/' page for an individual user.

3. Append this at the bottom-most of settings.py in mysite:
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/'

## HINT: If you want to get everything from the logged in user, just type the 
response.user inide of a function that you choose to get/access the db. This code
spits all of the information for that user (name,email,password,etc.).

12. Making a Specific Pages for each User

1. In main/models.py import user:
from django.contrib.auth.models import User

2. Add the user(showed below) for allowing user to have list:
class todolist(models.Model):
	user = 	models.ForeignKey(User,on_delete=models.CASCADE,related_name='todolist',null=True)	# ADDED LINE
	name = models.CharField(max_length = 200)

	def __str__(self):
		return self.name

3. Makemigrations (staging) and migrate(commit). If an error occured, delete your db,
your pycache, and files inside migrations except __init__.py.

4. To save the todolist in the database for a specific user only, we need to modify
the create() function on views.py to get and save the users data:
		if form.is_valid():
			# get the raw data name
			n = form.cleaned_data['name']
			# adds it to as our new todolist
			t = todolist(name=n)
			t.save()
			response.user.todolist_set.add(t)	# ADDED

5. Since we have a list() function that returns all list, that is functional for now
and needs a little edit;
- Delete the 1st line in lists() function and items inside the list:
def lists(response):
	return render(response,'main/lists.html',{})

6. Modify the lists.html:
{% extends "main/base.html" %}

{% block title %}All Lists{% endblock %}

{% block content %}
	<h1>My List</h1>
	<form method="post" action="#">
		{% csrf_token %}
			{% for td in user.todolist.all %}
				<p><a href="/{{td.id}}">{{td}}</a></p>
			{% endfor %}
	</form>
{% endblock %}

7. We had a log in accounts but we can still access todolists of others. To stop this,
we must type "if cnt in response.user.todolist.all():" on index() function below the
cnt variable,append all the codes below it on that fuction olny and then at the bottom
of that function, in line of the first if statement, type:
"return render(response,'main/home.html',{})" so your index() should look like this:
def index(response,id):
	cnt = todolist.objects.get(id = id)

	if cnt in response.user.todolist.all():						## NEW LINE
		if response.method == 'POST':
			print(response.POST)
			if response.POST.get('save'):
				for item in cnt.item_set.all():
					if response.POST.get("c" + str(item.id)) == 'clicked':
						item.complete = True
					else:
						item.complete = False
					item.save()	

			elif response.POST.get('newItem'):
				txt = response.POST.get("new")
				if  len(txt) > 2:
					cnt.item_set.create(text=txt,complete=False)
				else:
					print('INVALID')

		return render(response,'main/list.html',{'cnt':cnt})
	return render(response,'main/home.html',{})					## NEW LINE

-- And that's a simpliest way to implement the django framework for web apps!!